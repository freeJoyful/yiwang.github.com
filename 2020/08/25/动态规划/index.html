<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiwang-one.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概要主要用来求解最值。 三要素：最优子结构、重叠子问题、状态转移方程 具体来说，动态规划的⼀般流程就是三步：暴⼒的递归解法-&gt; 带备忘录的递归解法-&gt; 迭代的动态规划解法。就思考流程来说，就分为⼀下⼏步：找到状态和选择-&gt; 明确dp 数组&#x2F;函数的定义-&gt; 寻找状态之间的关系。 要⽤动态规划，那就要定义dp 数组，找状态转移关系。我们说的两种思路模板，就是dp 数组的定义思路">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="https://yiwang-one.github.io/2020/08/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Hi, I am yiwang.">
<meta property="og:description" content="概要主要用来求解最值。 三要素：最优子结构、重叠子问题、状态转移方程 具体来说，动态规划的⼀般流程就是三步：暴⼒的递归解法-&gt; 带备忘录的递归解法-&gt; 迭代的动态规划解法。就思考流程来说，就分为⼀下⼏步：找到状态和选择-&gt; 明确dp 数组&#x2F;函数的定义-&gt; 寻找状态之间的关系。 要⽤动态规划，那就要定义dp 数组，找状态转移关系。我们说的两种思路模板，就是dp 数组的定义思路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213611479.png">
<meta property="og:image" content="c:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213646224.png">
<meta property="og:image" content="c:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822121823692.png">
<meta property="article:published_time" content="2020-08-24T17:04:54.028Z">
<meta property="article:modified_time" content="2020-08-24T17:08:08.872Z">
<meta property="article:author" content="wang yi wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213611479.png">

<link rel="canonical" href="https://yiwang-one.github.io/2020/08/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>动态规划 | Hi, I am yiwang.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hi, I am yiwang.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/08/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-25 01:04:54 / 修改时间：01:08:08" itemprop="dateCreated datePublished" datetime="2020-08-25T01:04:54+08:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>主要用来求解最值。</p>
<p>三要素：最优子结构、重叠子问题、状态转移方程</p>
<p>具体来说，动态规划的⼀般流程就是三步：暴⼒的递归解法-&gt; 带备忘录的递归解法-&gt; 迭代的动态规划解法。<br>就思考流程来说，就分为⼀下⼏步：找到状态和选择-&gt; 明确dp 数组/函数的定义-&gt; 寻找状态之间的关系。</p>
<p>要⽤动态规划，那就要定义dp 数组，找状态转移关系。我们说的两种思路模板，就是dp 数组的定义思路。不同的问题可能需要不同的dp 数组定<br>义来解决。</p>
<a id="more"></a>

<p>⼀、两种思路<br>1、第⼀种思路模板是⼀个⼀维的dp 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; array.length;</span><br><span class="line">int[] dp &#x3D; new int[n];</span><br><span class="line">for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">		dp[i] &#x3D; 最值(dp[i], dp[j] + ...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<p>在⼦数组array[0..i] 中，我们要求的⼦序列（最⻓递增⼦序列）的⻓度<br>是dp[i] 。</p>
<p>2、第⼆种思路模板是⼀个⼆维的dp 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; arr.length;</span><br><span class="line">int[][] dp &#x3D; new dp[n][n];</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (arr[i] &#x3D;&#x3D; arr[j])</span><br><span class="line">			dp[i][j] &#x3D; dp[i][j] + ...</span><br><span class="line">		else</span><br><span class="line">			dp[i][j] &#x3D; 最值(...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种思路运⽤相对更多⼀些，尤其是涉及两个字符串/数组的⼦序列，⽐如前⽂讲的「最⻓公共⼦序列」。本思路中dp 数组含义⼜分为「只涉及⼀个字符串」和「涉及两个字符串」两种情况。<br>2.1 涉及两个字符串/数组时（⽐如最⻓公共⼦序列），dp 数组的含义如下：<br>    在⼦数组arr1[0..i] 和⼦数组arr2[0..j] 中，我们要求的⼦序列（最⻓公共⼦序列）⻓度为dp[i][j] 。</p>
<p>​    例如：「编辑距离」「公共⼦序列」</p>
<p>2.2 只涉及⼀个字符串/数组时，dp 数组的含义如下：</p>
<p>​    在⼦数组array[i..j] 中，我们要求的⼦序列（最⻓回⽂⼦序列）的⻓度为dp[i][j] 。<br>​    例如: 最⻓回⽂⼦序列</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a></h3><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>求最值；最长递增子序列，其子问题也应该是最长的；存在重复的子问题。考虑有动态规划算法。</p>
</li>
<li><p>确定状态：i： 第 i 个元素；</p>
<p>状态函数: dp(i): 以num[i] 为结尾的最长子序列长度。</p>
<p>状态转移：1）可写出转移方程，2）或者写出状态转移伪代码。</p>
<p>假设已知道dp(0)到dp(i - 1)的值，如何求dp(i)?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp(i) &#x3D;&#x3D;&gt; k 属于[0, i - 1]</span><br><span class="line">for (k -&gt; 0 ~ i -1) &#123;</span><br><span class="line">	if (num[i] &gt; num[k]) &#123;</span><br><span class="line">		dp(i) &#x3D; max(dp(i), dp(k) + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int findNumberOfLIS(int[] nums) &#123;</span><br><span class="line">    if (nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[nums.length];</span><br><span class="line">    int[] counter &#x3D; new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    Arrays.fill(counter, 1);</span><br><span class="line">    int maxLen &#x3D; 0;</span><br><span class="line">    int maxValCnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        for (int k &#x3D; 0; k &lt; i; ++k) &#123;</span><br><span class="line">            if (nums[i] &lt;&#x3D; nums[k]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[k] + 1 &gt; dp[i]) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[k] + 1;</span><br><span class="line">                counter[i] &#x3D; counter[k];</span><br><span class="line">            &#125; else if (dp[k] + 1 &#x3D;&#x3D; dp[i]) &#123;</span><br><span class="line">                counter[i] +&#x3D; counter[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen &#x3D; Math.max(maxLen, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; counter.length; ++i) &#123;</span><br><span class="line">        if (dp[i] &#x3D;&#x3D; maxLen) &#123;</span><br><span class="line">            maxValCnt +&#x3D; counter[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h3><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。</p>
<p> 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>符合动态规划算法要求</p>
</li>
<li><p>dp[i]: 以num[i]为结尾的最长连续递增序列长度</p>
</li>
<li><p>若已知dp[0]~dp[i - 1]，如何求dp[i]?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (num[i] &gt; num[i - 1]) &#123;</span><br><span class="line">	dp[i] &#x3D; dp[i - 1] + 1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	dp[i] &#x3D;  1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D;  new int[nums.length];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    int res &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        for (int k &#x3D; 0; k &lt; i; ++k) &#123;</span><br><span class="line">            if (nums[k] &gt;&#x3D; nums[i]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i], dp[k] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="若要求所有上升子序列列表，怎么求？"><a href="#若要求所有上升子序列列表，怎么求？" class="headerlink" title="若要求所有上升子序列列表，怎么求？"></a>若要求所有上升子序列列表，怎么求？</h3><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h3><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>具有动态规划法三要素。⼀旦涉及到⼦序列和最值，那⼏乎可以肯定，考察的是动态规划技巧，时间复杂度⼀般都是O(n^2)。原因很简单，你想想⼀个字符串，它的⼦序列有多少种可能？起码是指数级的吧，这种情况下，不⽤动态规划技巧，还想怎么着？</p>
</li>
<li><p>从概要中知道，这个问题对dp 数组的定义是：在⼦串s[i..j] 中，最⻓回⽂⼦序列<br>的⻓度为dp[i][j]。⼀定要记住这个定义才能理解算法。</p>
</li>
<li><p>假设知道了⼦问题dp[i+1][j-1]的结果（s[i+1..j-1] 中最⻓回⽂⼦序列的⻓度），你是否能想办法算出<br>dp[i][j] 的值（s[i..j] 中，最⻓回⽂⼦序列的⻓度）呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] &#x3D;&#x3D; s[j])</span><br><span class="line">	&#x2F;&#x2F; 它俩⼀定在最⻓回⽂⼦序列中</span><br><span class="line">	dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</span><br><span class="line">else</span><br><span class="line">	&#x2F;&#x2F; s[i+1..j] 和s[i..j-1] 谁的回⽂⼦序列更⻓？</span><br><span class="line">	dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>知道了转换函数，要注意遍历方式。</p>
<p>看看刚才写的状态转移⽅程，想求dp[i][j] 需要知道dp[i+1][j- 1] ，dp[i+1][j] ，dp[i][j-1] 这三个位置。</p>
</li>
</ul>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213611479.png" alt="image-20200822213611479"></p>
<p>因此选择从后往前遍历：</p>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213646224.png" alt="image-20200822213646224"></p>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">      int len &#x3D; s.length();</span><br><span class="line">      if (len &lt;&#x3D; 0) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (len &#x3D;&#x3D; 1) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 默认情况下int 值为0</span><br><span class="line">      int[][] dp &#x3D; new int[len][len];</span><br><span class="line">      for (int i &#x3D; 0; i &lt; len; ++i) &#123;</span><br><span class="line">          for (int j &#x3D; 0; j &lt; len; ++j) &#123;</span><br><span class="line">              dp[i][j] &#x3D; 0;</span><br><span class="line">              if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; 1;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">          for (int j &#x3D; i + 1; j &lt; len; ++j) &#123;</span><br><span class="line">              if (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] &#x3D; Math.max(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[0][len - 1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>1、⼀定要明确dp 数组的含义。对于两个字符串的动态规划问题，套路是通⽤的。</p>
<p>dp[i][j] 的含义是：对于s1[1..i] 和s2[1..j] ，它们的LCS ⻓度是dp[i][j] 。(下标从1开始标记）</p>
</li>
<li><p>2、定义base case。dp[0][..] 和dp[..][0] 都应该初始化为0。</p>
</li>
<li><p>3、找到状态转移方程。若已知dp[i - 1][j - 1] ， 如何求dp[i][j] ？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if str1[i] &#x3D;&#x3D; str2[j]:</span><br><span class="line">	dp[i, j] &#x3D; dp[i - 1, j - 1] + 1;</span><br><span class="line">else:</span><br><span class="line">	dp[i, j] &#x3D; max(dp[i-1, j], dp[i, j-1]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">      int len1 &#x3D; text1.length();</span><br><span class="line">      int len2 &#x3D; text2.length();</span><br><span class="line">      if (text1 &#x3D;&#x3D; null || text2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (text1.isEmpty() || text2.isEmpty()) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 行列多留一位，并置为0，表示&quot;&quot;串与其他字符串的LCS长度为0</span><br><span class="line">      int[][] dp &#x3D; new int[len1 + 1][len2 + 1];</span><br><span class="line">      for (int i &#x3D; 0; i &lt;&#x3D; len1; ++i) &#123;</span><br><span class="line">          dp[i][0] &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int j &#x3D; 0; j &lt;&#x3D; len2; ++j) &#123;</span><br><span class="line">          dp[0][j] &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; 1; i &lt;&#x3D; len1; ++i) &#123;</span><br><span class="line">          for (int j &#x3D; 1; j &lt;&#x3D; len2; ++j) &#123;</span><br><span class="line">              if (text1.charAt(i - 1) &#x3D;&#x3D; text2.charAt(j - 1)) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[len1][len2];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3><p>给你k 种⾯值的硬币，⾯值分别为c1, c2 … ck ，每种硬币的数量⽆限，再给⼀个总⾦额amount ，问你最少需要⼏枚硬币凑出这个⾦额，如果不可能凑出，算法返回-1 。</p>
<p><strong>思路</strong></p>
<ul>
<li><p>dp[i] : 当总额为i时，需要的最少硬币数量。</p>
</li>
<li><p>每个金额都需要考虑所有的coins，所以需要遍历coins, 如何求dp[i] ? 当前硬币选不选？选则数量加一，并关注 dp[i - coin]， 不选则等于自己dp[i]。两者取其小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i - coin &lt; 0) continue;</span><br><span class="line">	dp[i] &#x3D; min(dp[i], 1 + dp[i - coin]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822121823692.png" alt="image-20200822121823692"></p>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">    if (amount &lt;&#x3D; 0 || coins &#x3D;&#x3D; null || coins.length &lt; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[amount + 1];</span><br><span class="line">    Arrays.fill(dp, amount + 1);</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; amount + 1; ++i) &#123;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            if (i - coin &gt;&#x3D; 0) &#123;</span><br><span class="line">                dp[i] &#x3D; Math.min(dp[i], dp[i - coin] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] &#x3D;&#x3D; amount + 1 ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>完全背包问题(每个物品数量无限)：</p>
<p>有⼀个背包，最⼤容量为amount ，有⼀系列物品coins ，每个物品的重量为coins[i] ，每个物品的数量⽆限。请问有多少种⽅法，能够把背包恰好装满？</p>
</li>
<li><p>状态： 可选择物品，背包容量</p>
</li>
<li><p>dp数组： dp[i][j] 的定义如下：若只使⽤前i 个物品，当背包容量为j 时，有dp[i][j]种⽅法可以装<br>满背包。即：若只使⽤coins 中的前i 个硬币的⾯值，若想凑出⾦额j ，有dp[i][j] 种凑法。</p>
<p>base case: dp[0] [..] = 0，dp[..] [0] = 1 </p>
<p>最终结果：dp[N] [amount]</p>
</li>
<li><pre><code>// 选择不选择第i 个物品?
// 选择，则其组合数等于剩下金额的组合数，即 dp[i][j-coins[i-1]] （注意下标，i,j 从1开始计数， 当作coins下标时要减一）。
// 不选择，则其组合数等于选择前一个硬币的组合数。
// 因为求组合总数，需要将两者选择相加
for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= amount; j++) {
        if (j - coins[i-1] &gt;= 0)
            dp[i][j] = dp[i - 1][j]
                + dp[i][j-coins[i-1]];
return dp[N][W]

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**结果**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###  [面试题 08.11. 硬币](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;coin-lcci&#x2F;)</span><br><span class="line"></span><br><span class="line">硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 按照题意完全与 [39. 组合总和](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;combination-sum&#x2F;) 一模一样，但是使用回溯算法会超时。</span><br><span class="line">* 属于完全背包问题，与[518. 零钱兑换 II](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;coin-change-2&#x2F;) 一模一样</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
  public int waysToChange(int n) {
      int[] coins = {1, 5, 10, 25};
      int[][] dp = new int[coins.length + 1][n + 1];
      for (int i = 0; i &lt;= coins.length; ++i) {
          dp[i][0] = 1;
      }
      for (int i = 1; i &lt;= coins.length; ++i) {
          for (int j = 1; j &lt;= n; ++j) {
              if (j - coins[i - 1] &gt;= 0) {
                  dp[i][j] = (dp[i - 1][j] + dp[i][j - coins[i - 1]]) % 1000000007;
              } else {
                  dp[i][j] = dp[i - 1][j] % 1000000007;
              }
          }
      }
      return dp[coins.length][n];
  }
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [416. 分割等和子集](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;partition-equal-subset-sum&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">每个数组中的元素不会超过 100</span><br><span class="line">数组的大小不会超过 200</span><br><span class="line"></span><br><span class="line">**示例 1:**</span><br></pre></td></tr></table></figure>
输入: [1, 5, 11, 5]
</code></pre></li>
</ul>
<p>输出: true</p>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 题目可以转换成：给定一个只包含正整数的非空数组，是否存在一组和，使得该和为 sum&#x2F;2。—— 0&#x2F;1背包问题</span><br><span class="line"></span><br><span class="line">* dp[i] [j] : 选择前 i个元素，能否构成目标和 j</span><br><span class="line"></span><br><span class="line">  base case: dp[0] [j] &#x3D; false; dp[i] [0] &#x3D; ture;</span><br><span class="line"></span><br><span class="line">  若不选择第i个num: 则 dp[i] [j] &#x3D; dp[i - 1] [j]；</span><br><span class="line"></span><br><span class="line">  若选择第i个num:  则 dp[i] [j] &#x3D; dp[i - 1] [j - num[i - 1]]；&#x2F;&#x2F; 因为每个元素只能被选择一次，所以为dp[i - 1]； 且dp[i] [j] 下标从1开始计算，所以为num[i - 1]</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public boolean canPartition(int[] nums) {
    if (nums == null || nums.length &lt;= 1) {
        return false;
    }
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) {
        return false;
    }
    sum = sum / 2;
    boolean[][] dp = new boolean[nums.length + 1][sum + 1];
    for (int i = 0; i &lt;= nums.length; ++i) {
        dp[i][0] =  true;
    }
    for (int i = 1; i &lt;= nums.length; ++i) {
        for (int j = 1; j &lt;= sum; ++j) {
            if (j - nums[i - 1] &gt;= 0) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[nums.length][sum];
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 编辑距离</span><br><span class="line"></span><br><span class="line">### [72. 编辑距离](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;edit-distance&#x2F;)</span><br><span class="line"></span><br><span class="line">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line"></span><br><span class="line">插入一个字符</span><br><span class="line">删除一个字符</span><br><span class="line">替换一个字符</span><br><span class="line"></span><br><span class="line">示例 1：</span><br></pre></td></tr></table></figure>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 属于解决两个字符串的动态规划问题。1）求最少操作数(最值)， 2）最少操作的中间操作也一定是最少的(最优子结构)，3）需要重复计算一些中间步骤</span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public int minDistance(String word1, String word2) {
    int len1 = word1.length();
    int len2 = word2.length();
    // 定义dp,明确dp含义
    int[][] dp = new int[len1 + 1][len2 + 1];
    // 初始化 base case
    for (int i = 0; i &lt;= len1; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j &lt;= len2; ++j) {
        dp[0][j] = j;
    }
    // 遍历求解
    for (int i = 1; i &lt;= len1; ++i) {
        for (int j = 1; j &lt;= len2; ++j) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, // 替换
                        Math.min(dp[i - 1][j] + 1, //
                        dp[i][j - 1] + 1));
            }
        }
    }
    return dp[len1][len2];
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 股票买卖</span><br><span class="line"></span><br><span class="line">### 概述</span><br><span class="line"></span><br><span class="line">* 状态：</span><br><span class="line"></span><br><span class="line">  这个问题的「状态」有三个，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的rest 的状态，我们不妨⽤1 表⽰持有，0 表⽰没有持有）</span><br></pre></td></tr></table></figure>
<p>  dp[i][k][0 or 1]<br>  0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K<br>  n 为天数，⼤K 为最多交易数<br>  for 0 &lt;= i &lt; n:<br>      for 1 &lt;= k &lt;= K:<br>          for s in {0, 1}:<br>              dp[i][k][s] = max(buy, sell, rest)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 状态数组: 表示在第 &#96;i&#96; 天结束时，**最多**进行 &#96;k&#96; 次交易的情况下可以获得的最大收益</span><br></pre></td></tr></table></figure><br>  dp[i][k][0 or 1]<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 最终结果：</span><br></pre></td></tr></table></figure><br>  dp[n - 1][M][0]<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 选择：买入(buy)，卖出(sell)，无操作(reset)</span><br><span class="line"></span><br><span class="line">* base case:</span><br></pre></td></tr></table></figure><br>  dp[-1][k][0] = 0<br>  解释：因为i 是从0 开始的，所以i = -1 意味着还没有开始，这时候的利润当然是0.<br>  注：为什么i是从0开始的？因为题目给的第i天的股价的数组下标是从0开始的。<br>  dp[-1][k][1] = -infinity<br>  解释：还没开始的时候，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。<br>  dp[i][0][0] = 0<br>  解释：因为k 是从1 开始的，所以k = 0 意味着根本不允许交易，这时候利润当然是0<br>  dp[i][0][1] = -infinity<br>  解释：不允许交易的情况下，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 状态转移：根据选择来进行状态变化。</span><br></pre></td></tr></table></figure><br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  max( 选择rest , 选择sell )<br>  解释：今天我没有持有股票，有两种可能：<br>  要么是我昨天就没有持有，然后今天选择rest(无操作)，所以我今天还是没有持有；<br>  要么是我昨天持有股票，但是今天我sell 了，所以我今天没有持有股票了。<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  max( 选择rest , 选择buy )<br>  解释：今天我持有着股票，有两种可能：<br>  要么我昨天就持有着股票，然后今天选择rest，所以我今天还持有着股票；<br>  要么我昨天本没有持有，但今天我选择buy，所以今天我就持有股票了。<br>  注：买入卖出为一次交易，k的值只需变化一次。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 总结：</span><br></pre></td></tr></table></figure><br>  base case：<br>  dp[-1][k][0] = dp[i][0][0] = 0<br>  dp[-1][k][1] = dp[i][0][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [121. 买卖股票的最佳时机](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure><br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 1; 按照框架直接写出base 和状态转移方程：</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  dp[-1][1][0] = dp[i][0][0] = 0<br>  dp[-1][1][1] = dp[i][0][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>  dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])<br>              = max(dp[i-1][1][1],  - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  现在发现k 都是1，不会改变，即k 对状态转移已经没有影响了（因为当k=0是，所有结果都为0）。<br>  可以进⾏进⼀步化简去掉所有k：<br>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], -prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0; // 第1天（下标从0开始）未持有，则收益为0<br>        dp[0][1] = prices[0] * -1; // 第1天（下标从0开始）持有，则少了买入的钱<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1],  prices[i] * -1);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1,  -prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [122. 买卖股票的最佳时机 II](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-ii&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line"></span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 正无穷；则k变化与否没有影响</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  dp[-1][0] = 0<br>  dp[-1][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit2(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit2(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [123. 买卖股票的最佳时机 III](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iii&#x2F;)</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  for (int k = 0; k &lt;= m; ++k) {<br>      if (k == 0) {<br>          dp[0][k][0] = 0;<br>          dp[0][k][1] =  Integer.MIN_VALUE; // 不存在这种可能<br>          continue;<br>      }<br>      dp[0][k][0] = 0; // 第一天，<br>      dp[0][k][1] = -prices[0];<br>  }<br>  状态转移⽅程：<br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit3(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int m = 2;<br>        int[][][] dp = new int[n][m + 1][2];<br>        for (int k = 0; k &lt;= m; ++k) {<br>            if (k == 0) {<br>                dp[0][k][0] = 0;<br>                dp[0][k][1] =  Integer.MIN_VALUE;<br>                continue;<br>            }<br>            dp[0][k][0] = 0;<br>            dp[0][k][1] = -prices[0];<br>        }<br>        for (int i = 1; i &lt; n; ++i) {<br>            for (int k = 1; k &lt;= m; ++k) {<br>                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>                dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);<br>            }<br>        }<br>        return dp[n - 1][m][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [188. 买卖股票的最佳时机 IV](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iv&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><br><span class="line"></span><br><span class="line">注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 有了上⼀题k &#x3D; 2 的铺垫，这题应该和上⼀题的第⼀个解法没啥区别。但是出现了⼀个超内存的错误，原来是传⼊的k 值会⾮常⼤，dp 数组太⼤了。现在想想，交易次数k 最多有多⼤呢？⼀次交易由买⼊和卖出构成，⾄少需要两天。所以说有效的限制k 应该不超过n&#x2F;2，如果超过，就没有约束作⽤了，相当于k &#x3D; +infinity。这种情况是之前解决过的。直接把之前的代码重⽤：</span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit(int k, int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    if (k &gt; (n / 2)) {
        return maxProfitWithInfinityChances(prices);
    }
    int[][][] dp = new int[n][k + 1][2];
    for (int j = 0; j &lt;= k; ++j) {
        if (j == 0) {
            dp[0][j][0] = 0;
            dp[0][j][1] =  Integer.MIN_VALUE;
            continue;
        }
        dp[0][j][0] = 0;
        dp[0][j][1] = -prices[0];
    }
    for (int i = 1; i &lt; n; ++i) {
        for (int j = 1; j &lt;= k; ++j) {
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[n - 1][k][0];
}

public int maxProfitWithInfinityChances(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [309. 最佳买卖股票时机含冷冻期](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-cooldown&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</span><br><span class="line"></span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line"></span><br><span class="line">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><br><span class="line"></span><br><span class="line">**示例:**</span><br></pre></td></tr></table></figure>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 每次sell 之后要等⼀天才能继续交易。只要把这个特点融⼊上⼀题的状态转</span><br><span class="line">  移⽅程即可：</span><br></pre></td></tr></table></figure>
<p>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])<br>  解释：第i 天选择buy 的时候，要从i-2 的状态转移，⽽不是i-1 。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br>        for (int i = 1; i &lt; n; ++i) {<br>            if (i == 1) {<br>                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);<br>            } else {<br>                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);<br>            }<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit5(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_0_pre = 0; // dp_i_0 的前一天状态
    int dp_i_1 = Integer.MIN_VALUE; // 初始状态 dp_0_i 是不被允许的，设置为无效值
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0; // dp_i_0后面会被修改，所以要保存一下
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_i_0_pre - prices[i]);
        dp_i_0_pre = tmp;
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [714. 买卖股票的最佳时机含手续费](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-transaction-fee&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</span><br><span class="line"></span><br><span class="line">你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span><br><span class="line"></span><br><span class="line">返回获得利润的最大值。</span><br><span class="line"></span><br><span class="line">注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">*  统一在买入的时候扣除手续费</span><br></pre></td></tr></table></figure>
<p>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i] - fee)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices, int fee) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0] - fee; // 买入时扣费<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            // 买入时扣费<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   // 通过上面的数组形式，一步一步替换<br>   public int maxProfit(int[] prices, int fee) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int dp_i_0 = 0;<br>        int dp_i_1 = Integer.MIN_VALUE; // 初始状态 dp_0_i 是不被允许的，设置为无效值</p>
<pre><code>    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // 这里要用到替换前的dp_i_o值，所以需要保存一份改变前的dp_i_0
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i] - fee); 
    }
    return dp_i_0;
}</code></pre><pre><code></code></pre>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="prev" title="分布式">
      <i class="fa fa-chevron-left"></i> 分布式
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概要"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题目"><span class="nav-number">2.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#子序列问题"><span class="nav-number">2.1.</span> <span class="nav-text">子序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#673-最长递增子序列的个数"><span class="nav-number">2.1.1.</span> <span class="nav-text">673. 最长递增子序列的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#674-最长连续递增序列"><span class="nav-number">2.1.2.</span> <span class="nav-text">674. 最长连续递增序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-number">2.1.3.</span> <span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#若要求所有上升子序列列表，怎么求？"><span class="nav-number">2.1.4.</span> <span class="nav-text">若要求所有上升子序列列表，怎么求？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-最长回文子序列"><span class="nav-number">2.1.5.</span> <span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-最长公共子序列"><span class="nav-number">2.1.6.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背包问题"><span class="nav-number">2.2.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">2.2.1.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-零钱兑换-II"><span class="nav-number">2.2.2.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wang yi wang</p>
  <div class="site-description" itemprop="description">来这里，查看更多技术的分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wang yi wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
