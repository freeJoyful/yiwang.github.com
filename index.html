<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiwang-one.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来这里，查看更多技术的分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Hi, I am yiwang.">
<meta property="og:url" content="https://yiwang-one.github.io/index.html">
<meta property="og:site_name" content="Hi, I am yiwang.">
<meta property="og:description" content="来这里，查看更多技术的分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wang yi wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yiwang-one.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hi, I am yiwang.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hi, I am yiwang.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/08/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 01:04:54" itemprop="dateCreated datePublished" datetime="2020-08-25T01:04:54+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-26 01:37:37" itemprop="dateModified" datetime="2020-08-26T01:37:37+08:00">2020-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>主要用来求解最值。</p>
<p>三要素：最优子结构、重叠子问题、状态转移方程</p>
<p>具体来说，动态规划的⼀般流程就是三步：暴⼒的递归解法-&gt; 带备忘录的<br>递归解法-&gt; 迭代的动态规划解法。<br>就思考流程来说，就分为⼀下⼏步：找到状态和选择-&gt; 明确dp 数组/函数<br>的定义-&gt; 寻找状态之间的关系。</p>
<p>要⽤动态规划，那就要定义dp 数组，找状态转移关系。我们说的两种<br>思路模板，就是dp 数组的定义思路。不同的问题可能需要不同的dp 数组定<br>义来解决。</p>
<p>⼀、两种思路<br>1、第⼀种思路模板是⼀个⼀维的dp 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; array.length;</span><br><span class="line">int[] dp &#x3D; new int[n];</span><br><span class="line">for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">		dp[i] &#x3D; 最值(dp[i], dp[j] + ...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<p>在⼦数组array[0..i] 中，我们要求的⼦序列（最⻓递增⼦序列）的⻓度<br>是dp[i] 。</p>
<p>2、第⼆种思路模板是⼀个⼆维的dp 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; arr.length;</span><br><span class="line">int[][] dp &#x3D; new dp[n][n];</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (arr[i] &#x3D;&#x3D; arr[j])</span><br><span class="line">			dp[i][j] &#x3D; dp[i][j] + ...</span><br><span class="line">		else</span><br><span class="line">			dp[i][j] &#x3D; 最值(...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种思路运⽤相对更多⼀些，尤其是涉及两个字符串/数组的⼦序列，⽐如前⽂讲的「最⻓公共⼦序列」。本思路中dp 数组含义⼜分为「只涉及⼀个字符串」和「涉及两个字符串」两种情况。<br>2.1 涉及两个字符串/数组时（⽐如最⻓公共⼦序列），dp 数组的含义如下：<br>    在⼦数组arr1[0..i] 和⼦数组arr2[0..j] 中，我们要求的⼦序列（最⻓公共⼦序列）⻓度为dp[i][j] 。</p>
<p>​    例如：「编辑距离」「公共⼦序列」</p>
<p>2.2 只涉及⼀个字符串/数组时，dp 数组的含义如下：</p>
<p>​    在⼦数组array[i..j] 中，我们要求的⼦序列（最⻓回⽂⼦序列）的⻓度为dp[i][j] 。<br>​    例如: 最⻓回⽂⼦序列</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a></h3><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>求最值；最长递增子序列，其子问题也应该是最长的；存在重复的子问题。考虑有动态规划算法。</p>
</li>
<li><p>确定状态：i： 第 i 个元素；</p>
<p>状态函数: dp(i): 以num[i] 为结尾的最长子序列长度。</p>
<p>状态转移：1）可写出转移方程，2）或者写出状态转移伪代码。</p>
<p>假设已知道dp(0)到dp(i - 1)的值，如何求dp(i)?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp(i) &#x3D;&#x3D;&gt; k 属于[0, i - 1]</span><br><span class="line">for (k -&gt; 0 ~ i -1) &#123;</span><br><span class="line">	if (num[i] &gt; num[k]) &#123;</span><br><span class="line">		dp(i) &#x3D; max(dp(i), dp(k) + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int findNumberOfLIS(int[] nums) &#123;</span><br><span class="line">    if (nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[nums.length];</span><br><span class="line">    int[] counter &#x3D; new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    Arrays.fill(counter, 1);</span><br><span class="line">    int maxLen &#x3D; 0;</span><br><span class="line">    int maxValCnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        for (int k &#x3D; 0; k &lt; i; ++k) &#123;</span><br><span class="line">            if (nums[i] &lt;&#x3D; nums[k]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[k] + 1 &gt; dp[i]) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[k] + 1;</span><br><span class="line">                counter[i] &#x3D; counter[k];</span><br><span class="line">            &#125; else if (dp[k] + 1 &#x3D;&#x3D; dp[i]) &#123;</span><br><span class="line">                counter[i] +&#x3D; counter[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen &#x3D; Math.max(maxLen, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; counter.length; ++i) &#123;</span><br><span class="line">        if (dp[i] &#x3D;&#x3D; maxLen) &#123;</span><br><span class="line">            maxValCnt +&#x3D; counter[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h3><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。</p>
<p> 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>符合动态规划算法要求</p>
</li>
<li><p>dp[i]: 以num[i]为结尾的最长连续递增序列长度</p>
</li>
<li><p>若已知dp[0]~dp[i - 1]，如何求dp[i]?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (num[i] &gt; num[i - 1]) &#123;</span><br><span class="line">	dp[i] &#x3D; dp[i - 1] + 1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	dp[i] &#x3D;  1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D;  new int[nums.length];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    int res &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        for (int k &#x3D; 0; k &lt; i; ++k) &#123;</span><br><span class="line">            if (nums[k] &gt;&#x3D; nums[i]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i], dp[k] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="若要求所有上升子序列列表，怎么求？"><a href="#若要求所有上升子序列列表，怎么求？" class="headerlink" title="若要求所有上升子序列列表，怎么求？"></a>若要求所有上升子序列列表，怎么求？</h3><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h3><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>具有动态规划法三要素。⼀旦涉及到⼦序列和最值，那⼏乎可以肯定，考察的是动态规划技巧，时间复杂度⼀般都是O(n^2)。原因很简单，你想想⼀个字符串，它的⼦序列有多少种可能？起码是指数级的吧，这种情况下，不⽤动态规划技巧，还想怎么着？</p>
</li>
<li><p>从概要中知道，这个问题对dp 数组的定义是：在⼦串s[i..j] 中，最⻓回⽂⼦序列<br>的⻓度为dp[i][j]。⼀定要记住这个定义才能理解算法。</p>
</li>
<li><p>假设知道了⼦问题dp[i+1][j-1]的结果（s[i+1..j-1] 中最⻓回⽂⼦序列的⻓度），你是否能想办法算出<br>dp[i][j] 的值（s[i..j] 中，最⻓回⽂⼦序列的⻓度）呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] &#x3D;&#x3D; s[j])</span><br><span class="line">	&#x2F;&#x2F; 它俩⼀定在最⻓回⽂⼦序列中</span><br><span class="line">	dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</span><br><span class="line">else</span><br><span class="line">	&#x2F;&#x2F; s[i+1..j] 和s[i..j-1] 谁的回⽂⼦序列更⻓？</span><br><span class="line">	dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>知道了转换函数，要注意遍历方式。</p>
<p>看看刚才写的状态转移⽅程，想求dp[i][j] 需要知道dp[i+1][j- 1] ，dp[i+1][j] ，dp[i][j-1] 这三个位置。</p>
</li>
</ul>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213611479.png" alt="image-20200822213611479"></p>
<p>因此选择从后往前遍历：</p>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822213646224.png" alt="image-20200822213646224"></p>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">      int len &#x3D; s.length();</span><br><span class="line">      if (len &lt;&#x3D; 0) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (len &#x3D;&#x3D; 1) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 默认情况下int 值为0</span><br><span class="line">      int[][] dp &#x3D; new int[len][len];</span><br><span class="line">      for (int i &#x3D; 0; i &lt; len; ++i) &#123;</span><br><span class="line">          for (int j &#x3D; 0; j &lt; len; ++j) &#123;</span><br><span class="line">              dp[i][j] &#x3D; 0;</span><br><span class="line">              if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; 1;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">          for (int j &#x3D; i + 1; j &lt; len; ++j) &#123;</span><br><span class="line">              if (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] &#x3D; Math.max(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[0][len - 1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>1、⼀定要明确dp 数组的含义。对于两个字符串的动态规划问题，套路是通⽤的。</p>
<p>dp[i][j] 的含义是：对于s1[1..i] 和s2[1..j] ，它们的LCS ⻓度是dp[i][j] 。(下标从1开始标记）</p>
</li>
<li><p>2、定义base case。dp[0][..] 和dp[..][0] 都应该初始化为0。</p>
</li>
<li><p>3、找到状态转移方程。若已知dp[i - 1][j - 1] ， 如何求dp[i][j] ？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if str1[i] &#x3D;&#x3D; str2[j]:</span><br><span class="line">	dp[i, j] &#x3D; dp[i - 1, j - 1] + 1;</span><br><span class="line">else:</span><br><span class="line">	dp[i, j] &#x3D; max(dp[i-1, j], dp[i, j-1]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">      int len1 &#x3D; text1.length();</span><br><span class="line">      int len2 &#x3D; text2.length();</span><br><span class="line">      if (text1 &#x3D;&#x3D; null || text2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (text1.isEmpty() || text2.isEmpty()) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 行列多留一位，并置为0，表示&quot;&quot;串与其他字符串的LCS长度为0</span><br><span class="line">      int[][] dp &#x3D; new int[len1 + 1][len2 + 1];</span><br><span class="line">      for (int i &#x3D; 0; i &lt;&#x3D; len1; ++i) &#123;</span><br><span class="line">          dp[i][0] &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int j &#x3D; 0; j &lt;&#x3D; len2; ++j) &#123;</span><br><span class="line">          dp[0][j] &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; 1; i &lt;&#x3D; len1; ++i) &#123;</span><br><span class="line">          for (int j &#x3D; 1; j &lt;&#x3D; len2; ++j) &#123;</span><br><span class="line">              if (text1.charAt(i - 1) &#x3D;&#x3D; text2.charAt(j - 1)) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[len1][len2];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3><p>给你k 种⾯值的硬币，⾯值分别为c1, c2 … ck ，每种硬币的数量⽆限，再给⼀个总⾦额amount ，问你最少需要⼏枚硬币凑出这个⾦额，如果不可能凑出，算法返回-1 。</p>
<p><strong>思路</strong></p>
<ul>
<li><p>dp[i] : 当总额为i时，需要的最少硬币数量。</p>
</li>
<li><p>每个金额都需要考虑所有的coins，所以需要遍历coins, 如何求dp[i] ? 当前硬币选不选？选则数量加一，并关注 dp[i - coin]， 不选则等于自己dp[i]。两者取其小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i - coin &lt; 0) continue;</span><br><span class="line">	dp[i] &#x3D; min(dp[i], 1 + dp[i - coin]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="C:%5CUsers%5Cwang_%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200822121823692.png" alt="image-20200822121823692"></p>
<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">    if (amount &lt;&#x3D; 0 || coins &#x3D;&#x3D; null || coins.length &lt; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp &#x3D; new int[amount + 1];</span><br><span class="line">    Arrays.fill(dp, amount + 1);</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; amount + 1; ++i) &#123;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            if (i - coin &gt;&#x3D; 0) &#123;</span><br><span class="line">                dp[i] &#x3D; Math.min(dp[i], dp[i - coin] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] &#x3D;&#x3D; amount + 1 ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li><p>完全背包问题(每个物品数量无限)：</p>
<p>有⼀个背包，最⼤容量为amount ，有⼀系列物品coins ，每个物品的重量为coins[i] ，每个物品的数量⽆限。请问有多少种⽅法，能够把背包恰好装满？</p>
</li>
<li><p>状态： 可选择物品，背包容量</p>
</li>
<li><p>dp数组： dp[i][j] 的定义如下：若只使⽤前i 个物品，当背包容量为j 时，有dp[i][j]种⽅法可以装<br>满背包。即：若只使⽤coins 中的前i 个硬币的⾯值，若想凑出⾦额j ，有dp[i][j] 种凑法。</p>
<p>base case: dp[0] [..] = 0，dp[..] [0] = 1 </p>
<p>最终结果：dp[N] [amount]</p>
</li>
<li><pre><code>// 选择不选择第i 个物品?
// 选择，则其组合数等于剩下金额的组合数，即 dp[i][j-coins[i-1]] （注意下标，i,j 从1开始计数， 当作coins下标时要减一）。
// 不选择，则其组合数等于选择前一个硬币的组合数。
// 因为求组合总数，需要将两者选择相加
for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= amount; j++) {
        if (j - coins[i-1] &gt;= 0)
            dp[i][j] = dp[i - 1][j]
                + dp[i][j-coins[i-1]];
return dp[N][W]

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**结果**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###  [面试题 08.11. 硬币](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;coin-lcci&#x2F;)</span><br><span class="line"></span><br><span class="line">硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 按照题意完全与 [39. 组合总和](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;combination-sum&#x2F;) 一模一样，但是使用回溯算法会超时。</span><br><span class="line">* 属于完全背包问题，与[518. 零钱兑换 II](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;coin-change-2&#x2F;) 一模一样</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
  public int waysToChange(int n) {
      int[] coins = {1, 5, 10, 25};
      int[][] dp = new int[coins.length + 1][n + 1];
      for (int i = 0; i &lt;= coins.length; ++i) {
          dp[i][0] = 1;
      }
      for (int i = 1; i &lt;= coins.length; ++i) {
          for (int j = 1; j &lt;= n; ++j) {
              if (j - coins[i - 1] &gt;= 0) {
                  dp[i][j] = (dp[i - 1][j] + dp[i][j - coins[i - 1]]) % 1000000007;
              } else {
                  dp[i][j] = dp[i - 1][j] % 1000000007;
              }
          }
      }
      return dp[coins.length][n];
  }
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [416. 分割等和子集](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;partition-equal-subset-sum&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">每个数组中的元素不会超过 100</span><br><span class="line">数组的大小不会超过 200</span><br><span class="line"></span><br><span class="line">**示例 1:**</span><br></pre></td></tr></table></figure>
输入: [1, 5, 11, 5]
</code></pre></li>
</ul>
<p>输出: true</p>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 题目可以转换成：给定一个只包含正整数的非空数组，是否存在一组和，使得该和为 sum&#x2F;2。—— 0&#x2F;1背包问题</span><br><span class="line"></span><br><span class="line">* dp[i] [j] : 选择前 i个元素，能否构成目标和 j</span><br><span class="line"></span><br><span class="line">  base case: dp[0] [j] &#x3D; false; dp[i] [0] &#x3D; ture;</span><br><span class="line"></span><br><span class="line">  若不选择第i个num: 则 dp[i] [j] &#x3D; dp[i - 1] [j]；</span><br><span class="line"></span><br><span class="line">  若选择第i个num:  则 dp[i] [j] &#x3D; dp[i - 1] [j - num[i - 1]]；&#x2F;&#x2F; 因为每个元素只能被选择一次，所以为dp[i - 1]； 且dp[i] [j] 下标从1开始计算，所以为num[i - 1]</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public boolean canPartition(int[] nums) {
    if (nums == null || nums.length &lt;= 1) {
        return false;
    }
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) {
        return false;
    }
    sum = sum / 2;
    boolean[][] dp = new boolean[nums.length + 1][sum + 1];
    for (int i = 0; i &lt;= nums.length; ++i) {
        dp[i][0] =  true;
    }
    for (int i = 1; i &lt;= nums.length; ++i) {
        for (int j = 1; j &lt;= sum; ++j) {
            if (j - nums[i - 1] &gt;= 0) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[nums.length][sum];
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 编辑距离</span><br><span class="line"></span><br><span class="line">### [72. 编辑距离](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;edit-distance&#x2F;)</span><br><span class="line"></span><br><span class="line">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line"></span><br><span class="line">插入一个字符</span><br><span class="line">删除一个字符</span><br><span class="line">替换一个字符</span><br><span class="line"></span><br><span class="line">示例 1：</span><br></pre></td></tr></table></figure>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 属于解决两个字符串的动态规划问题。1）求最少操作数(最值)， 2）最少操作的中间操作也一定是最少的(最优子结构)，3）需要重复计算一些中间步骤</span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public int minDistance(String word1, String word2) {
    int len1 = word1.length();
    int len2 = word2.length();
    // 定义dp,明确dp含义
    int[][] dp = new int[len1 + 1][len2 + 1];
    // 初始化 base case
    for (int i = 0; i &lt;= len1; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j &lt;= len2; ++j) {
        dp[0][j] = j;
    }
    // 遍历求解
    for (int i = 1; i &lt;= len1; ++i) {
        for (int j = 1; j &lt;= len2; ++j) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, // 替换
                        Math.min(dp[i - 1][j] + 1, //
                        dp[i][j - 1] + 1));
            }
        }
    }
    return dp[len1][len2];
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 股票买卖</span><br><span class="line"></span><br><span class="line">### 概述</span><br><span class="line"></span><br><span class="line">* 状态：</span><br><span class="line"></span><br><span class="line">  这个问题的「状态」有三个，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的rest 的状态，我们不妨⽤1 表⽰持有，0 表⽰没有持有）</span><br></pre></td></tr></table></figure>
<p>  dp[i][k][0 or 1]<br>  0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K<br>  n 为天数，⼤K 为最多交易数<br>  for 0 &lt;= i &lt; n:<br>      for 1 &lt;= k &lt;= K:<br>          for s in {0, 1}:<br>              dp[i][k][s] = max(buy, sell, rest)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 状态数组: 表示在第 &#96;i&#96; 天结束时，**最多**进行 &#96;k&#96; 次交易的情况下可以获得的最大收益</span><br></pre></td></tr></table></figure><br>  dp[i][k][0 or 1]<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 最终结果：</span><br></pre></td></tr></table></figure><br>  dp[n - 1][M][0]<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 选择：买入(buy)，卖出(sell)，无操作(reset)</span><br><span class="line"></span><br><span class="line">* base case:</span><br></pre></td></tr></table></figure><br>  dp[-1][k][0] = 0<br>  解释：因为i 是从0 开始的，所以i = -1 意味着还没有开始，这时候的利润当然是0.<br>  注：为什么i是从0开始的？因为题目给的第i天的股价的数组下标是从0开始的。<br>  dp[-1][k][1] = -infinity<br>  解释：还没开始的时候，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。<br>  dp[i][0][0] = 0<br>  解释：因为k 是从1 开始的，所以k = 0 意味着根本不允许交易，这时候利润当然是0<br>  dp[i][0][1] = -infinity<br>  解释：不允许交易的情况下，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 状态转移：根据选择来进行状态变化。</span><br></pre></td></tr></table></figure><br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  max( 选择rest , 选择sell )<br>  解释：今天我没有持有股票，有两种可能：<br>  要么是我昨天就没有持有，然后今天选择rest(无操作)，所以我今天还是没有持有；<br>  要么是我昨天持有股票，但是今天我sell 了，所以我今天没有持有股票了。<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  max( 选择rest , 选择buy )<br>  解释：今天我持有着股票，有两种可能：<br>  要么我昨天就持有着股票，然后今天选择rest，所以我今天还持有着股票；<br>  要么我昨天本没有持有，但今天我选择buy，所以今天我就持有股票了。<br>  注：买入卖出为一次交易，k的值只需变化一次。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 总结：</span><br></pre></td></tr></table></figure><br>  base case：<br>  dp[-1][k][0] = dp[i][0][0] = 0<br>  dp[-1][k][1] = dp[i][0][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [121. 买卖股票的最佳时机](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure><br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 1; 按照框架直接写出base 和状态转移方程：</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  dp[-1][1][0] = dp[i][0][0] = 0<br>  dp[-1][1][1] = dp[i][0][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>  dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])<br>              = max(dp[i-1][1][1],  - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  现在发现k 都是1，不会改变，即k 对状态转移已经没有影响了（因为当k=0是，所有结果都为0）。<br>  可以进⾏进⼀步化简去掉所有k：<br>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], -prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0; // 第1天（下标从0开始）未持有，则收益为0<br>        dp[0][1] = prices[0] * -1; // 第1天（下标从0开始）持有，则少了买入的钱<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1],  prices[i] * -1);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1,  -prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [122. 买卖股票的最佳时机 II](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-ii&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line"></span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 正无穷；则k变化与否没有影响</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  dp[-1][0] = 0<br>  dp[-1][1] = -infinity<br>  状态转移⽅程：<br>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit2(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit2(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [123. 买卖股票的最佳时机 III](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iii&#x2F;)</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* M &#x3D;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<p>  base case：<br>  for (int k = 0; k &lt;= m; ++k) {<br>      if (k == 0) {<br>          dp[0][k][0] = 0;<br>          dp[0][k][1] =  Integer.MIN_VALUE; // 不存在这种可能<br>          continue;<br>      }<br>      dp[0][k][0] = 0; // 第一天，<br>      dp[0][k][1] = -prices[0];<br>  }<br>  状态转移⽅程：<br>  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit3(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int m = 2;<br>        int[][][] dp = new int[n][m + 1][2];<br>        for (int k = 0; k &lt;= m; ++k) {<br>            if (k == 0) {<br>                dp[0][k][0] = 0;<br>                dp[0][k][1] =  Integer.MIN_VALUE;<br>                continue;<br>            }<br>            dp[0][k][0] = 0;<br>            dp[0][k][1] = -prices[0];<br>        }<br>        for (int i = 1; i &lt; n; ++i) {<br>            for (int k = 1; k &lt;= m; ++k) {<br>                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>                dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);<br>            }<br>        }<br>        return dp[n - 1][m][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [188. 买卖股票的最佳时机 IV](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iv&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><br><span class="line"></span><br><span class="line">注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 有了上⼀题k &#x3D; 2 的铺垫，这题应该和上⼀题的第⼀个解法没啥区别。但是出现了⼀个超内存的错误，原来是传⼊的k 值会⾮常⼤，dp 数组太⼤了。现在想想，交易次数k 最多有多⼤呢？⼀次交易由买⼊和卖出构成，⾄少需要两天。所以说有效的限制k 应该不超过n&#x2F;2，如果超过，就没有约束作⽤了，相当于k &#x3D; +infinity。这种情况是之前解决过的。直接把之前的代码重⽤：</span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit(int k, int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    if (k &gt; (n / 2)) {
        return maxProfitWithInfinityChances(prices);
    }
    int[][][] dp = new int[n][k + 1][2];
    for (int j = 0; j &lt;= k; ++j) {
        if (j == 0) {
            dp[0][j][0] = 0;
            dp[0][j][1] =  Integer.MIN_VALUE;
            continue;
        }
        dp[0][j][0] = 0;
        dp[0][j][1] = -prices[0];
    }
    for (int i = 1; i &lt; n; ++i) {
        for (int j = 1; j &lt;= k; ++j) {
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[n - 1][k][0];
}

public int maxProfitWithInfinityChances(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i]);
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [309. 最佳买卖股票时机含冷冻期](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-cooldown&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</span><br><span class="line"></span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line"></span><br><span class="line">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><br><span class="line"></span><br><span class="line">**示例:**</span><br></pre></td></tr></table></figure>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 每次sell 之后要等⼀天才能继续交易。只要把这个特点融⼊上⼀题的状态转</span><br><span class="line">  移⽅程即可：</span><br></pre></td></tr></table></figure>
<p>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])<br>  解释：第i 天选择buy 的时候，要从i-2 的状态转移，⽽不是i-1 。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br>        for (int i = 1; i &lt; n; ++i) {<br>            if (i == 1) {<br>                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);<br>            } else {<br>                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);<br>            }<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int maxProfit5(int[] prices) {
    int n;
    if (prices == null || (n = prices.length) &lt;= 0) {
        return 0;
    }
    int dp_i_0 = 0;
    int dp_i_0_pre = 0; // dp_i_0 的前一天状态
    int dp_i_1 = Integer.MIN_VALUE; // 初始状态 dp_0_i 是不被允许的，设置为无效值
    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0; // dp_i_0后面会被修改，所以要保存一下
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_i_0_pre - prices[i]);
        dp_i_0_pre = tmp;
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [714. 买卖股票的最佳时机含手续费](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-transaction-fee&#x2F;)</span><br><span class="line"></span><br><span class="line">给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</span><br><span class="line"></span><br><span class="line">你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span><br><span class="line"></span><br><span class="line">返回获得利润的最大值。</span><br><span class="line"></span><br><span class="line">注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">*  统一在买入的时候扣除手续费</span><br></pre></td></tr></table></figure>
<p>  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>  dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i] - fee)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure><br>    public int maxProfit(int[] prices, int fee) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int[][] dp = new int[n][2];<br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0] - fee; // 买入时扣费<br>        for (int i = 1; i &lt; n; ++i) {<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            // 买入时扣费<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);<br>        }<br>        return dp[n - 1][0];<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   // 通过上面的数组形式，一步一步替换<br>   public int maxProfit(int[] prices, int fee) {<br>        int n;<br>        if (prices == null || (n = prices.length) &lt;= 0) {<br>            return 0;<br>        }<br>        int dp_i_0 = 0;<br>        int dp_i_1 = Integer.MIN_VALUE; // 初始状态 dp_0_i 是不被允许的，设置为无效值</p>
<pre><code>    for (int i = 0; i &lt; n; ++i) {
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // 这里要用到替换前的dp_i_o值，所以需要保存一份改变前的dp_i_0
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i] - fee); 
    }
    return dp_i_0;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 打家劫舍</span><br><span class="line"></span><br><span class="line">### [198. 打家劫舍](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber&#x2F;)</span><br><span class="line"></span><br><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br></pre></td></tr></table></figure>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 状态 i: 第i间房</span><br><span class="line">* dp[i]： 抢劫到第i间房时，获得的最高金额。</span><br><span class="line">* 选择：每间房抢或者不抢。只有没有抢过前面房间时才能抢现在的房间，每间房都能选择不抢</span><br><span class="line">* 状态转移：dp[i] &#x3D; max(dp[i - 2] + num[i], dp[i - 1]);</span><br><span class="line">* base case: dp[0] &#x3D; 0; dp[1] &#x3D; num[0]</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public int rob(int[] nums) {
    if (nums == null || nums.length &lt;= 0) {
        return 0;
    }
    int[] dp = new int[nums.length + 1];
    dp[0] = 0;
    dp[1] = nums[0];
    for (int i = 2; i &lt;= nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
    }
    return dp[nums.length];
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public int rob(int[] nums) {
    if (nums == null || nums.length &lt;= 0) {
        return 0;
    }
    int dp_cur = 0;
    int dp_pre = 0;
    int dp_pre_pre = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        dp_cur = Math.max(dp_pre_pre + nums[i], dp_pre);
        dp_pre_pre = dp_pre;
        dp_pre = dp_cur;
    }
    return dp_cur;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [213. 打家劫舍 II](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber-ii&#x2F;)</span><br><span class="line"></span><br><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* ⾸先，⾸尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第⼀间房⼦被抢最后⼀间不抢；要么最后⼀间房⼦被抢第⼀间不抢。</span><br><span class="line"></span><br><span class="line">![image-20200826011240245](C:\Users\wang_\AppData\Roaming\Typora\typora-user-images\image-20200826011240245.png)</span><br><span class="line"></span><br><span class="line">那就简单了啊，这三种情况，那种的结果最⼤，就是最终答案呗！不过，其实我们不需要⽐较三种情况，只要⽐较情况⼆和情况三就⾏了，因为这两种情况对于房⼦的选择余地⽐情况⼀⼤呀，房⼦⾥的钱数都是⾮负数，所以选择余地⼤，最优决策结果肯定不会⼩。所以只需对之前的解法稍作修改即可：</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public int rob(int[] nums) {
    int len;
    if (nums == null || (len = nums.length) &lt;= 0) {
        return 0;
    }
    return Math.max(robRange(nums, 0, len - 2), robRange(nums, 1, len - 1));
}

private int robRange(int[] nums, int start, int end) {
    if (nums.length == 1) {
        return nums[0];
    }
    if (nums.length == 2) {
        return Math.max(nums[0], nums[1]);
    }
    int dp_cur = 0;
    int dp_pre = 0;
    int dp_pre_pre = 0;

    for (int i = start; i &lt;= end; i++) {
        dp_cur = Math.max(dp_pre_pre + nums[i], dp_pre);
        dp_pre_pre = dp_pre;
        dp_pre = dp_cur;
    }
    return dp_cur;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [337. 打家劫舍 III](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber-iii&#x2F;)</span><br><span class="line"></span><br><span class="line">在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</span><br><span class="line"></span><br><span class="line">计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p>输入: [3,2,3,null,3,null,1]</p>
<pre><code> 3
/ \</code></pre><p>   2   3<br>    \   \<br>     3   1</p>
<p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">* 还是分为抢还是不抢</span><br><span class="line">* 中序遍历</span><br><span class="line"></span><br><span class="line">**实现**</span><br></pre></td></tr></table></figure>
<pre><code>public class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;
   TreeNode(int x) { val = x; }
}
private Map&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();
public int rob(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (memo.containsKey(root)) {
        return memo.get(root);
    }
    int doRob = root.val +
            ((root.left == null) ? 0 : rob(root.left.left) + rob(root.left.right)) +
            ((root.right == null) ? 0 : rob(root.right.right) + rob(root.right.left));

    int notRob =  rob(root.left) + rob(root.right);
    int res = Math.max(doRob, notRob);
    memo.put(root, res);
    return res;
}</code></pre><pre><code></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-title-link" itemprop="url">分布式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 00:37:41 / 修改时间：00:39:44" itemprop="dateCreated datePublished" datetime="2020-08-10T00:37:41+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><ul>
<li><p>redis内存不足，如何解决</p>
</li>
<li><p>redis高可用方案</p>
</li>
<li><p>redis等前沿技术栈的知识面</p>
</li>
<li><p>一道简单的系统设计题：</p>
<p>用redis做限流</p>
</li>
<li><p>redis相关的zset结构</p>
</li>
<li><p>redis内存回收</p>
</li>
<li><p>kafka，rocketMq，同步机制和事务机制</p>
</li>
<li><p>redis主从怎么实现</p>
</li>
<li><p>redis的常用数据结构、持久化方式、写入时rdb机制</p>
</li>
<li><p>redis分布式锁</p>
</li>
<li><p>rabbitMq的替代方式</p>
</li>
<li><p>nginx惊群效应</p>
</li>
<li><p>I多路复用的原理，在redis和Mysql的实现</p>
</li>
<li><p>redis，rehash的实现</p>
</li>
<li><p>redis事务以及实现方式</p>
</li>
<li><p>dubbo的容错机制有哪些、负载均衡机制有哪些</p>
</li>
<li><p>redis和memcached</p>
</li>
<li><p>redis的hash和string的区别以及各自的优势和使用场景</p>
</li>
<li><p>redis单节点和集群的优缺点</p>
</li>
<li><p>redis高可用实现、redis过期怎么处理</p>
</li>
<li><p>redis数据结构和实现</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 00:37:41 / 修改时间：00:39:58" itemprop="dateCreated datePublished" datetime="2020-08-10T00:37:41+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="面试题目链接"><a href="#面试题目链接" class="headerlink" title="面试题目链接"></a>面试题目链接</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/78982303" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78982303</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1645514817836645220&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1645514817836645220&amp;wfr=spider&amp;for=pc</a></li>
</ul>
<h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul>
<li><p>Oracle MySql特性、优劣势</p>
</li>
<li><p>MySql基础知识</p>
</li>
<li><p>Sql编程：每门课程都大于80分的学生名字</p>
</li>
<li><p>数据库分表/分库/集群</p>
</li>
<li><p>数据库两种引擎的比较</p>
</li>
<li><p>innodb和miysam存储实现区别</p>
</li>
<li><p>数据库表(id, name, parentID)如何组装成树</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/08/07/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/07/Java/" class="post-title-link" itemprop="url">Java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-07 02:15:31" itemprop="dateCreated datePublished" datetime="2020-08-07T02:15:31+08:00">2020-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-10 00:39:31" itemprop="dateModified" datetime="2020-08-10T00:39:31+08:00">2020-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、Java-IO-NIO"><a href="#一、Java-IO-NIO" class="headerlink" title="一、Java IO/NIO"></a>一、Java IO/NIO</h2><h3 id="1-IO"><a href="#1-IO" class="headerlink" title="1. IO"></a>1. IO</h3><p>I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，I/O 问题尤其突出，很容易成为一个性能瓶颈。正因如此，所以 Java 在 I/O 上也一直在做持续的优化，如从 1.4 开始引入了 NIO，提升了 I/O 的性能。关于 NIO 我们将在后面详细介绍。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/07/Java/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/07/31/%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/31/%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91/" class="post-title-link" itemprop="url">技术方向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-31 00:56:04 / 修改时间：01:01:12" itemprop="dateCreated datePublished" datetime="2020-07-31T00:56:04+08:00">2020-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="技术方向准备"><a href="#技术方向准备" class="headerlink" title="技术方向准备"></a>技术方向准备</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/07/31/%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwang-one.github.io/2020/05/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang yi wang">
      <meta itemprop="description" content="来这里，查看更多技术的分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, I am yiwang.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">基础算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 22:59:08" itemprop="dateCreated datePublished" datetime="2020-05-26T22:59:08+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-07 23:02:00" itemprop="dateModified" datetime="2020-08-07T23:02:00+08:00">2020-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基础算法记录"><a href="#基础算法记录" class="headerlink" title="基础算法记录"></a>基础算法记录</h4><ul>
<li>排序算法<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>快速排序</li>
<li>归并排序</li>
</ul>
</li>
<li>搜索算法
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wang yi wang</p>
  <div class="site-description" itemprop="description">来这里，查看更多技术的分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wang yi wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
